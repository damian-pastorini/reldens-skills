
const { EventsManager, ErrorManager, Logger, sc } = require('@reldens/utils');
const SkillsEvents = require('./skills-events');

class LevelsSet
{

    constructor(props)
    {
        if(!sc.hasOwn(props, 'owner')){
            ErrorManager.error('Undefined owner for levels.');
        }
        if(!sc.hasOwn(props, 'levels') || !Object.keys(props.levels).length){
            ErrorManager.error('Levels were not specified.');
        }
        this.owner = props.owner;
        this.ownerIdProperty = sc.hasOwn(props, 'ownerIdProperty') ? props.ownerIdProperty : 'id';
        this.events = sc.hasOwn(props, 'events') ? props.events : EventsManager;
        // @NOTE: if autoFillRanges is enabled you could have the first level with key = 1 and the next with key = 5,
        // this way the setLevels will fill up levels 2, 3 and 4 with the same level Object so the same level modifiers
        // will be applied automatically (same calculation for multiple levels).
        this.autoFillRanges = sc.hasOwn(props, 'autoFillRanges') ? props.autoFillRanges : false;
        this.currentLevel = sc.hasOwn(props, 'currentLevel') ? props.currentLevel : 0;
        this.currentExp = sc.hasOwn(props, 'currentExp') ? props.currentExp : 0;
        // set levels is almost the last thing to happen here, first we need to validate all the other parameters:
        this.levels = this.setLevels(props.levels);
        // @NOTE: if you setup levelsByExperience and autoFillRanges at the same time the levels autogenerated will be
        // skipped because the experience on those will be lower one. For example, level 1 required experience = 10p,
        // level 5 required experience = 20p, level 2, 3 and 4 are auto-generated with required exp. = 20p, so when the
        // player reach 20p of experience it will jump to level 5. In summary you shouldn't mix these options unless
        // you expect the described behavior.
        this.increaseLevelsWithExperience = sc.hasOwn(props, 'increaseLevelsWithExperience')
            ? props.increaseLevelsWithExperience : true;
        // unless specified, levels by experience must just be sorted by their key attribute (without auto-fill):
        this.levelsByExperience = sc.hasOwn(props, 'levelsByExperience') ?
            props.levelsByExperience : this.sortLevelsBy(props.levels);
    }

    setLevels(levels)
    {
        if(!this.autoFillRanges){
            this.levels = levels;
        } else {
            this.levels = {};
            let levelsKeys = Object.keys(levels);
            for(let i of levelsKeys){
                let level = levels[i];
                this.levels[i] = level;
                let levelsKeysNextIndex = levelsKeys.indexOf(i) + 1;
                let nextLevelKey = levelsKeys.length > levelsKeysNextIndex ? levelsKeys[levelsKeysNextIndex] : false;
                let nextLevel = false;
                if(sc.hasOwn(levels, (nextLevelKey))){
                    nextLevel = levels[nextLevelKey];
                }
                if(nextLevel && (nextLevel.key - level.key) > 0){
                    for(let n = level.key; n < nextLevel.key; n++){
                        this.levels[n] = level;
                    }
                }
            }
        }
        this.events.emit(SkillsEvents.SET_LEVELS, this, levels);
        return this.levels;
    }

    sortLevelsBy(levels, sortField)
    {
        if(!sortField){
            sortField = 'key';
        }
        return Object.keys(levels).sort((a,b) => {
            return (levels[a][sortField] > levels[b][sortField]) ? 1 : -1;
        });
    }

    levelUp()
    {
        let lastLevelKey = Object.keys(this.levels).pop();
        if(this.currentLevel >= this.levels[lastLevelKey].key){
            // reached top level:
            return false;
        }
        // first we need to increase the level:
        this.currentLevel++;
        // then apply the new level modifiers:
        this.applyLevelModifiers();
        this.events.emit(SkillsEvents.LEVEL_UP, this);
    }

    levelDown()
    {
        if(this.currentLevel <= 1){
            // reached first level:
            return false;
        }
        // here we first need to revert the modifiers of the current level:
        this.applyLevelModifiers(true);
        // then reduce the level:
        this.currentLevel--;
        this.events.emit(SkillsEvents.LEVEL_DOWN, this);
    }

    applyLevelModifiers(revert)
    {
        let currentLevelInstance = this.getCurrentLevelInstance();
        if(!currentLevelInstance){
            // this will usually happen if you don't set a proper end level without required experience.
            Logger.error(['Current level instance not found.', 'Current Level Key:', this.currentLevel]);
            return false;
        }
        this.events.emit(SkillsEvents.LEVEL_APPLY_MODIFIERS, this, currentLevelInstance);
        for(let modifier of currentLevelInstance.modifiers){
            if(revert){
                modifier.revert(this.owner);
            } else {
                modifier.apply(this.owner);
            }
        }
    }

    getCurrentLevelInstance()
    {
        // @NOTE: if you only specify 1 level the same calculation will be used for all the levels.
        let currentLevelInstance = false;
        if(sc.hasOwn(this.levels, this.currentLevel)){
            currentLevelInstance = this.levels[this.currentLevel];
        }
        return currentLevelInstance;
    }

    addExperience(number)
    {
        let newTotalExp = this.currentExp + number;
        let currentLevelIndex = this.levelsByExperience.indexOf(this.currentLevel.toString());
        let nextLevelIndex = currentLevelIndex + 1;
        let nextLevelKey = this.levelsByExperience[nextLevelIndex];
        let nextLevel = this.levels[nextLevelKey];
        if(sc.hasOwn(this.levels, this.currentLevel) && nextLevel && newTotalExp >= nextLevel.requiredExperience){
            for(let levelByExp of this.levelsByExperience.slice(nextLevelIndex)){
                if(newTotalExp >= this.levels[levelByExp].requiredExperience){
                    this.levelUp();
                }
            }
        }
        this.currentExp = newTotalExp;
        this.events.emit(SkillsEvents.LEVEL_EXPERIENCE_ADDED, this, number);
    }

    getOwnerId()
    {
        return this.owner[this.ownerIdProperty];
    }

}

module.exports = LevelsSet;